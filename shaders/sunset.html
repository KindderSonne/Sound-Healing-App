<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Sunset Volumetric Shader</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="container"></div>

    <script>
        const container = document.getElementById('container');

        // 1. Setup Three.js với WebGL 2.0
        // Shader này dùng hàm tanh() nên bắt buộc phải có WebGL 2
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('webgl2', { alpha: false });

        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            context: context,
            antialias: false
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 2. Shader Code
        const fragmentShader = `
        precision highp float;
        
        uniform vec3 iResolution;
        uniform float iTime;
        
        // Output cho WebGL 2.0
        out vec4 outColor;

        // --- BẮT ĐẦU CODE SHADERTOY ---
        
        /*
            "Sunset" by @XorDev
            Expanded and clarified version of my Sunset shader:
            https://www.shadertoy.com/view/wXjSRt
        */

        //Output image brightness
        #define BRIGHTNESS 1.0

        //Base brightness (higher = brighter, less saturated)
        #define COLOR_BASE 1.5
        //Color cycle speed (radians per second)
        #define COLOR_SPEED 0.5
        //RGB color phase shift (in radians)
        #define RGB vec3(0.0, 1.0, 2.0)
        //Color translucency strength
        #define COLOR_WAVE 14.0
        //Color direction and (magnitude = frequency)
        #define COLOR_DOT vec3(1,-1,0)

        //Wave iterations (higher = slower)
        #define WAVE_STEPS 8.0
        //Starting frequency
        #define WAVE_FREQ 5.0
        //Wave amplitude
        #define WAVE_AMP 0.6
        //Scaling exponent factor
        #define WAVE_EXP 1.8
        //Movement direction
        #define WAVE_VELOCITY vec3(0.2)

        //Cloud thickness (lower = denser)
        #define PASSTHROUGH 0.2

        //Cloud softness
        #define SOFTNESS 0.005
        //Raymarch step
        #define STEPS 100.0
        //Sky brightness factor (finicky)
        #define SKY 10.0
        //Camera fov ratio (tan(fov_y/2))
        #define FOV 1.0

        void mainImage(out vec4 fragColor, in vec2 fragCoord)
        {
            //Raymarch depth
            float z = 0.0;
            
            //Step distance
            float d = 0.0;
            //Signed distance
            float s = 0.0;
            
            //Ray direction
            vec3 dir = normalize( vec3(2.0*fragCoord - iResolution.xy, - FOV * iResolution.y));
            
            //Output color
            vec3 col = vec3(0);
            
            //Clear fragcolor and raymarch with 100 iterations
            for(float i = 0.0; i<STEPS; i++)
            {
                //Compute raymarch sample point
                vec3 p = z * dir;
                
                //Turbulence loop
                for(float j = 0.0, f = WAVE_FREQ; j<WAVE_STEPS; j++, f *= WAVE_EXP)
                    p += WAVE_AMP*sin(p*f - WAVE_VELOCITY*iTime).yzx / f;
                    
                //Compute distance to top and bottom planes
                s = 0.3 - abs(p.y);
                //Soften and scale inside the clouds
                d = SOFTNESS + max(s, -s*PASSTHROUGH) / 4.0;
                //Step forward
                z += d;
                //Coloring with signed distance, position and cycle time
                float phase = COLOR_WAVE * s + dot(p,COLOR_DOT) + COLOR_SPEED*iTime;
                //Apply RGB phase shifts, add base brightness and correct for sky
                col += (cos(phase - RGB) + COLOR_BASE) * exp(s*SKY) / d;
            }
            //Tanh tonemapping
            col *= SOFTNESS / STEPS * BRIGHTNESS;
            fragColor = vec4(tanh(col * col), 1.0);
        }
        
        // --- KẾT THÚC CODE SHADERTOY ---

        void main() {
            mainImage(outColor, gl_FragCoord.xy);
        }
    `;

        // 3. Uniforms
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) }
        };

        // 4. Material Setup
        const material = new THREE.ShaderMaterial({
            glslVersion: THREE.GLSL3, // Quan trọng: Sử dụng GLSL 3.0 cho WebGL 2
            uniforms: uniforms,
            fragmentShader: fragmentShader,
            vertexShader: `
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        `
        });

        // 5. Mesh Setup
        const plane = new THREE.PlaneGeometry(2, 2);
        const quad = new THREE.Mesh(plane, material);
        scene.add(quad);

        // 6. Resize Handler
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
        });

        // 7. Render Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            uniforms.iTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>