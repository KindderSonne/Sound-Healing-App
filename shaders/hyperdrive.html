<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Vortex by Kishimisu - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="container"></div>

    <script>
        const container = document.getElementById('container');

        // 1. Setup Three.js
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 2. Uniforms
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) }
        };

        // 3. Shader Code (Đã giải nén và sửa lỗi)
        const fragmentShader = `
        precision highp float;
        
        uniform vec3 iResolution;
        uniform float iTime;

        // Hàm trộn (mix) tùy chỉnh từ shader gốc
        // t(g, o, l, f) -> mix(g, o, cos(l * (f + iTime * 0.1)) * 0.5 + 0.5)
        float t_mix(float g, float o, float l, float f) {
            return mix(g, o, cos(l * (f + iTime * 0.1)) * 0.5 + 0.5);
        }

        void mainImage(out vec4 O, vec2 F) {
            // Khởi tạo các biến (Code gốc để tự do, WebGL cần khai báo rõ)
            float g = 0.0; // Loop counter
            float o = 0.0; // Ray distance (total)
            float l = 0.0; // Cell ID (integer part of Z)
            float f = 3.0; // SDF distance (current step)
            
            vec2 i = iResolution.xy;
            vec2 n = (F + F - i) / i.y; // Normalized UV (-1 to 1)

            // Vòng lặp Raymarching
            // Code gốc: for (; g++ < 2e2 && f > .001;)
            for (int k = 0; k < 200; k++) {
                if (f <= 0.001) break; // Dừng nếu chạm vật thể

                // Ray Direction & Position
                vec3 e = o * normalize(vec3(n, 1.0));
                
                // Di chuyển camera tới trước
                e.z += iTime * 0.5;
                
                // Lấy ID của ô không gian hiện tại (cho việc random hóa)
                l = floor(e.z + 0.5);
                
                // Giới hạn biên (Tunnel bound) - giữ tia không đi quá xa khỏi tâm
                // Đây là biến f tạm thời trước khi tính SDF chi tiết
                float tunnel_bound = 2.0 - length(e.xy) - o * 0.1;
                
                // Lặp lại không gian (Space Repetition)
                e = fract(e + 0.5) - 0.5;
                
                // --- Tính toán SDF (Signed Distance Function) ---
                
                // Code gốc có lỗi cú pháp ở đoạn t(.1,.4,.5,) -> Thiếu tham số cuối.
                // Dựa trên logic, tham số thiếu thường là 'l' (ID của ô).
                // Đoạn logic này tạo ra các vòng tròn biến dạng xoắn ốc.
                
                // Radius biến đổi
                float r_mod = t_mix(0.1, 0.5, 2.0, l);
                
                // Thickness biến đổi (Sửa lỗi thiếu tham số tại đây bằng 'l')
                float th_mod = t_mix(0.1, 0.4, 0.5, l);
                
                // Hình dạng Torus biến thể
                float d_shape = length(vec2(length(e.xy) - r_mod, e.z));
                
                // Trừ đi độ dày để tạo rỗng
                d_shape -= t_mix(0.05, th_mod, 1.0, 1.6 + l);
                
                // Kết hợp giới hạn đường hầm và hình dạng vật thể
                f = 0.5 * max(tunnel_bound, d_shape);
                
                // Cộng dồn khoảng cách
                o += f;
                
                g += 1.0; // Tăng biến đếm bước
            }

            // Tính màu sắc (Glow effect)
            // Màu dựa trên khoảng cách (o) và vector pháp tuyến màn hình (n)
            vec3 colBase = cos(o * 8.0 + vec3(0, 1, 2) * 0.8);
            vec3 glow = (colBase * 5.0) / exp(o * 0.2 + length(n));
            
            O = vec4(glow, 1.0);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    `;

        // 4. Material & Mesh
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            fragmentShader: fragmentShader,
            vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`
        });

        const plane = new THREE.PlaneGeometry(2, 2);
        const quad = new THREE.Mesh(plane, material);
        scene.add(quad);

        // 5. Resize Event
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
        });

        // 6. Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            uniforms.iTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>