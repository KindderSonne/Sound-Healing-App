<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Star Nest - Ultra Smooth & Slow</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: black;
}
canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
</style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) {
  alert("WebGL not supported");
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();

// ================= Vertex Shader =================
const vertexSrc = `
attribute vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

// ================= Fragment Shader =================
const fragmentSrc = `
precision highp float;

uniform vec3  iResolution;
uniform float iTime;
uniform vec4  iMouse;

// Star Nest by Pablo Roman Andrioli
// License: MIT

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850
#define speed  0.010 

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;
    uv.y *= iResolution.y / iResolution.x;

    vec3 dir = vec3(uv * zoom, 1.0);
    float time = iTime * speed + 0.25;

    // --- CẤU HÌNH TỐC ĐỘ GÓC QUAY (Độ nhạy) ---
    // Giảm xuống 0.1 để dù chuột đi xa, góc quay chỉ nhích nhẹ
    float mouseSpeedX = 0.1; 
    float mouseSpeedY = 0.1;

    float a1 = 0.5 + iMouse.x / iResolution.x * mouseSpeedX;
    float a2 = 0.8 + iMouse.y / iResolution.y * mouseSpeedY;

    mat2 rot1 = mat2(cos(a1), sin(a1), -sin(a1), cos(a1));
    mat2 rot2 = mat2(cos(a2), sin(a2), -sin(a2), cos(a2));

    dir.xz *= rot1;
    dir.xy *= rot2;

    vec3 from = vec3(1.0, 0.5, 0.5);
    from += vec3(time * 2.0, time, -2.0);
    from.xz *= rot1;
    from.xy *= rot2;

    float s = 0.1;
    float fade = 1.0;
    vec3 v = vec3(0.0);

    for (int r = 0; r < volsteps; r++) {
        vec3 p = from + s * dir * 0.5;
        p = abs(vec3(tile) - mod(p, vec3(tile * 2.0)));

        float pa = 0.0;
        float a = 0.0;

        for (int i = 0; i < iterations; i++) {
            p = abs(p) / dot(p, p) - formuparam;
            a += abs(length(p) - pa);
            pa = length(p);
        }

        float dm = max(0.0, darkmatter - a * a * 0.001);
        a *= a * a;

        if (r > 6) fade *= 1.0 - dm;

        v += fade;
        v += vec3(s, s*s, s*s*s*s) * a * brightness * fade;

        fade *= distfading;
        s += stepsize;
    }

    v = mix(vec3(length(v)), v, saturation);
    fragColor = vec4(v * 0.01, 1.0);
}

void main() {
    vec4 color;
    mainImage(color, gl_FragCoord.xy);
    gl_FragColor = color;
}
`;

// ================= Compile helpers =================
function compile(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const program = gl.createProgram();
gl.attachShader(program, compile(gl.VERTEX_SHADER, vertexSrc));
gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fragmentSrc));
gl.linkProgram(program);
gl.useProgram(program);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1, 1, -1, -1, 1, 1, 1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const iResolutionLoc = gl.getUniformLocation(program, "iResolution");
const iTimeLoc = gl.getUniformLocation(program, "iTime");
const iMouseLoc = gl.getUniformLocation(program, "iMouse");

// ================= CẤU HÌNH ĐỘ MƯỢT (QUÁN TÍNH) =================

// Target: Vị trí chuột thực tế
let targetMouseX = window.innerWidth / 2;
let targetMouseY = window.innerHeight / 2;

// Current: Vị trí vẽ (đuổi theo Target)
let currentMouseX = targetMouseX;
let currentMouseY = targetMouseY;

// Smoothness: Càng nhỏ càng mượt (và càng trễ).
// 0.02 là rất mượt ("nặng"), tạo cảm giác cinematic.
const smoothness = 0.02; 

canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  targetMouseX = e.clientX - rect.left;
  targetMouseY = canvas.height - (e.clientY - rect.top);
});

let start = performance.now();
function render() {
  const t = (performance.now() - start) * 0.001;

  // Thuật toán nội suy tuyến tính (Lerp) để làm mềm chuyển động
  currentMouseX += (targetMouseX - currentMouseX) * smoothness;
  currentMouseY += (targetMouseY - currentMouseY) * smoothness;

  gl.uniform3f(iResolutionLoc, canvas.width, canvas.height, 1.0);
  gl.uniform1f(iTimeLoc, t);
  gl.uniform4f(iMouseLoc, currentMouseX, currentMouseY, 0.0, 0.0);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}
render();
</script>

</body>
</html>
