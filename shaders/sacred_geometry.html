<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sacred Geometries WebGL</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;

        uniform vec3 iResolution;
        uniform float iTime;

        /* --- Original Shader Code Starts Here --- */
        
        /*
        Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]
        Title: Sacred Geometries
        */

        #define PI 3.14159265359
        #define TWO_PI 6.28318530718
        #define MAX_ITER 3

        vec3 gradient(in float t,in vec3 a,in vec3 b,in vec3 c,in vec3 d){
            return a+b*cos(TWO_PI*(c*t+d));
        }

        mat2 rot2(in float a){
            float c=cos(a);
            float s=sin(a);
            return mat2(c,-s,s,c);
        }

        float scale(in float x,in float a,in float b,in float c,in float d){
            return(x-a)/(b-a)*(d-c)+c;
        }

        vec2 scale(in vec2 p,in float a,in float b,in float c,in float d){
            return vec2(scale(p.x,a,b,c,d),scale(p.y,a,b,c,d));
        }

        vec3 scale(in vec3 p,in float a,in float b,in float c,in float d){
            return vec3(scale(p.xy,a,b,c,d),scale(p.z,a,b,c,d));
        }

        vec4 scale(in vec4 p,in float a,in float b,in float c,in float d){
            return vec4(scale(p.xy,a,b,c,d),scale(p.zw,a,b,c,d));
        }

        float fold(in float x){
            return abs(mod(x+1.,2.)-1.);
        }

        vec2 fold(in vec2 p){
            return vec2(fold(p.x),fold(p.y));
        }

        vec3 fold(in vec3 p){
            return vec3(fold(p.xy),fold(p.z));
        }

        vec4 fold(in vec4 p){
            return vec4(fold(p.xy),fold(p.zw));
        }

        float cosine(in float x,in float s){
            float y=cos(fract(x)*PI);
            return floor(x)+.5-(.5*pow(abs(y),1./s)*sign(y));
        }

        vec2 cosine(in vec2 p,in float s){
            return vec2(cosine(p.x,s),cosine(p.y,s));
        }

        vec3 cosine(in vec3 p,in float s){
            return vec3(cosine(p.xy,s),cosine(p.z,s));
        }

        vec4 cosine(in vec4 p,in float s){
            return vec4(cosine(p.xy,s),cosine(p.zw,s));
        }

        vec2 adjustViewport(in vec2 uv,in vec2 r){
            return(uv*2.-r)/(r.x<r.y?r.x:r.y);
        }

        void mainImage(out vec4 fragColor,in vec2 fragCoord){
            // reference time
            float t=iTime*.125;
            
            const vec3 c1=vec3(.5);
            const vec3 c2=vec3(.5);
            const vec3 c3=vec3(1.);
            vec3 c4a=vec3(.7647,.8784,.9451);
            vec3 c4b=vec3(.4667,.549,.6);
            vec3 c4=mix(c4a,c4b,cosine(fold(t*2.5),1.));
            
            vec2 uv=adjustViewport(fragCoord.xy,iResolution.xy)*.75;
            
            // angle of rotation for each fractal layer;
            float theta=TWO_PI/scale(sin(t*.1),-1.,1.,1.,12.);
            
            // mirror-repetition of space
            uv=fold(uv);
            
            // get mirrored distance from origin
            float mag=length(uv);
            
            // copy global uv coordinates
            vec2 loc=uv;
            
            // initialize alpha
            float a=0.;
            
            // fractal zoom
            float base=2.+sin(t)*.5;
            
            // frequency of rings
            float fq=7.5+sin(mag-t*.5)*3.;
            
            // stroke edge
            float edge=cosine(fold(t*.1),2.5)*.008+.01;
            
            // stroke color
            vec3 col=vec3(0.);
            
            float blur=exp(-length(uv*mag));
            // generate fractal layers
            for(float i=0.;i<float(MAX_ITER);i+=1.){
                // rotate current layer
                loc*=rot2(pow(base,i)*theta);
                
                // fractalize
                loc=fract(loc*base)-.5;
                
                // fold layer
                loc=fold(loc);
                
                // get layer's distance from origin
                float d=length(loc)*blur;
                
                // distance to stroke
                d=sin(d*fq+t)/fq;
                d=abs(d);
                d=edge/d;
                d=cosine(d,1.5);
                d=pow(d,.5);
                
                col+=gradient(mag+i*.25-t*.5,c1,c2,c3,c4)*d;
            }
            
            fragColor=vec4(col,1.);
        }

        /* --- WebGL Entry Point --- */
        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    </script>

    <script>
        const canvas = document.getElementById("glcanvas");
        const gl = canvas.getContext("webgl");

        if (!gl) {
            alert("Unable to initialize WebGL. Your browser or machine may not support it.");
        }

        // Shader Compilation Helper
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create Program
        const vertexShaderSource = document.getElementById("vs").text;
        const fragmentShaderSource = document.getElementById("fs").text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(program));
        }

        // Buffer Setup (Full Screen Quad)
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0, 1.0,
            1.0, 1.0,
            -1.0, -1.0,
            1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Attribute & Uniform Locations
        const positionAttributeLocation = gl.getAttribLocation(program, "position");
        const resolutionLocation = gl.getUniformLocation(program, "iResolution");
        const timeLocation = gl.getUniformLocation(program, "iTime");

        // Resize logic
        function resizeCanvasToDisplaySize(canvas) {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                return true;
            }
            return false;
        }

        // Render Loop
        function render(time) {
            time *= 0.001; // Convert to seconds

            resizeCanvasToDisplaySize(canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.useProgram(program);

            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            // Pass uniforms to shader
            gl.uniform3f(resolutionLocation, gl.canvas.width, gl.canvas.height, 1.0);
            gl.uniform1f(timeLocation, time);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>

</html>