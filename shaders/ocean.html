<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Seascape - TDM</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
</head>

<body>
    <div id="container"></div>

    <script>
        const container = document.getElementById('container');

        // 1. GUI Parameters
        const params = {
            speed: 1.0,
            seaHeight: 0.6,
            seaChoppy: 4.0,
            seaSpeed: 0.8,
            seaFreq: 0.16,
            reset: function () {
                this.speed = 1.0;
                this.seaHeight = 0.6;
                this.seaChoppy = 4.0;
                this.seaSpeed = 0.8;
                this.seaFreq = 0.16;
                updateUniforms();
            }
        };

        // 2. Setup Three.js
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 3. Uniforms
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },
            iMouse: { value: new THREE.Vector4() },
            uSeaHeight: { value: params.seaHeight },
            uSeaChoppy: { value: params.seaChoppy },
            uSeaSpeed: { value: params.seaSpeed },
            uSeaFreq: { value: params.seaFreq }
        };

        // 4. Seascape Shader by Alexander Alekseev aka TDM - 2014
        // License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
        const fragmentShader = `
        uniform float iTime;
        uniform vec3 iResolution;
        uniform vec4 iMouse;
        uniform float uSeaHeight;
        uniform float uSeaChoppy;
        uniform float uSeaSpeed;
        uniform float uSeaFreq;

        const int NUM_STEPS = 32;
        const float PI = 3.141592;
        const float EPSILON = 1e-3;
        #define EPSILON_NRM (0.1 / iResolution.x)

        // sea
        const int ITER_GEOMETRY = 3;
        const int ITER_FRAGMENT = 5;
        const vec3 SEA_BASE = vec3(0.0, 0.09, 0.18);
        const vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;
        #define SEA_TIME (1.0 + iTime * uSeaSpeed)
        const mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);

        // math
        mat3 fromEuler(vec3 ang) {
            vec2 a1 = vec2(sin(ang.x), cos(ang.x));
            vec2 a2 = vec2(sin(ang.y), cos(ang.y));
            vec2 a3 = vec2(sin(ang.z), cos(ang.z));
            mat3 m;
            m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);
            m[1] = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);
            m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);
            return m;
        }

        float hash(vec2 p) {
            float h = dot(p, vec2(127.1, 311.7));    
            return fract(sin(h) * 43758.5453123);
        }

        float noise(in vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);    
            vec2 u = f * f * (3.0 - 2.0 * f);
            return -1.0 + 2.0 * mix(
                mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),
                mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), 
                u.y
            );
        }

        // lighting
        float diffuse(vec3 n, vec3 l, float p) {
            return pow(dot(n, l) * 0.4 + 0.6, p);
        }

        float specular(vec3 n, vec3 l, vec3 e, float s) {    
            float nrm = (s + 8.0) / (PI * 8.0);
            return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
        }

        // sky
        vec3 getSkyColor(vec3 e) {
            e.y = (max(e.y, 0.0) * 0.8 + 0.2) * 0.8;
            return vec3(pow(1.0 - e.y, 2.0), 1.0 - e.y, 0.6 + (1.0 - e.y) * 0.4) * 1.1;
        }

        // sea
        float sea_octave(vec2 uv, float choppy) {
            uv += noise(uv);        
            vec2 wv = 1.0 - abs(sin(uv));
            vec2 swv = abs(cos(uv));    
            wv = mix(wv, swv, wv);
            return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
        }

        float map(vec3 p) {
            float freq = uSeaFreq;
            float amp = uSeaHeight;
            float choppy = uSeaChoppy;
            vec2 uv = p.xz; 
            uv.x *= 0.75;
            
            float d, h = 0.0;    
            for(int i = 0; i < ITER_GEOMETRY; i++) {        
                d = sea_octave((uv + SEA_TIME) * freq, choppy);
                d += sea_octave((uv - SEA_TIME) * freq, choppy);
                h += d * amp;        
                uv *= octave_m; 
                freq *= 1.9; 
                amp *= 0.22;
                choppy = mix(choppy, 1.0, 0.2);
            }
            return p.y - h;
        }

        float map_detailed(vec3 p) {
            float freq = uSeaFreq;
            float amp = uSeaHeight;
            float choppy = uSeaChoppy;
            vec2 uv = p.xz; 
            uv.x *= 0.75;
            
            float d, h = 0.0;    
            for(int i = 0; i < ITER_FRAGMENT; i++) {        
                d = sea_octave((uv + SEA_TIME) * freq, choppy);
                d += sea_octave((uv - SEA_TIME) * freq, choppy);
                h += d * amp;        
                uv *= octave_m; 
                freq *= 1.9; 
                amp *= 0.22;
                choppy = mix(choppy, 1.0, 0.2);
            }
            return p.y - h;
        }

        vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
            float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
            fresnel = min(fresnel * fresnel * fresnel, 0.5);
            
            vec3 reflected = getSkyColor(reflect(eye, n));    
            vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12; 
            
            vec3 color = mix(refracted, reflected, fresnel);
            
            float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);
            color += SEA_WATER_COLOR * (p.y - uSeaHeight) * 0.18 * atten;
            
            color += specular(n, l, eye, 600.0 * inversesqrt(dot(dist, dist)));
            
            return color;
        }

        // tracing
        vec3 getNormal(vec3 p, float eps) {
            vec3 n;
            n.y = map_detailed(p);    
            n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.y;
            n.z = map_detailed(vec3(p.x, p.y, p.z + eps)) - n.y;
            n.y = eps;
            return normalize(n);
        }

        float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
            float tm = 0.0;
            float tx = 1000.0;    
            float hx = map(ori + dir * tx);
            if(hx > 0.0) {
                p = ori + dir * tx;
                return tx;   
            }
            float hm = map(ori);    
            for(int i = 0; i < NUM_STEPS; i++) {
                float tmid = mix(tm, tx, hm / (hm - hx));
                p = ori + dir * tmid;
                float hmid = map(p);        
                if(hmid < 0.0) {
                    tx = tmid;
                    hx = hmid;
                } else {
                    tm = tmid;
                    hm = hmid;
                }        
                if(abs(hmid) < EPSILON) break;
            }
            return mix(tm, tx, hm / (hm - hx));
        }

        vec3 getPixel(in vec2 coord, float time) {    
            vec2 uv = coord / iResolution.xy;
            uv = uv * 2.0 - 1.0;
            uv.x *= iResolution.x / iResolution.y;    
                
            // ray
            vec3 ang = vec3(sin(time * 3.0) * 0.1, sin(time) * 0.2 + 0.3, time);    
            vec3 ori = vec3(0.0, 3.5, time * 5.0);
            vec3 dir = normalize(vec3(uv.xy, -2.0)); 
            dir.z += length(uv) * 0.14;
            dir = normalize(dir) * fromEuler(ang);
            
            // tracing
            vec3 p;
            heightMapTracing(ori, dir, p);
            vec3 dist = p - ori;
            vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);
            vec3 light = normalize(vec3(0.0, 1.0, 0.8)); 
                     
            // color
            return mix(
                getSkyColor(dir),
                getSeaColor(p, n, light, dir, dist),
                pow(smoothstep(0.0, -0.02, dir.y), 0.2)
            );
        }

        // main
        void mainImage(out vec4 fragColor, in vec2 fragCoord) {
            float time = iTime * 0.3 + iMouse.x * 0.01;
            
            vec3 color = getPixel(fragCoord, time);
            
            // post
            fragColor = vec4(pow(color, vec3(0.65)), 1.0);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    `;

        // 5. Mesh & Material
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            fragmentShader: fragmentShader,
            vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`
        });

        const plane = new THREE.PlaneGeometry(2, 2);
        const quad = new THREE.Mesh(plane, material);
        scene.add(quad);

        // 6. GUI Setup
        const gui = new lil.GUI({ title: 'Seascape Controls' });

        function updateUniforms() {
            uniforms.uSeaHeight.value = params.seaHeight;
            uniforms.uSeaChoppy.value = params.seaChoppy;
            uniforms.uSeaSpeed.value = params.seaSpeed;
            uniforms.uSeaFreq.value = params.seaFreq;
        }

        gui.add(params, 'speed', 0.0, 3.0).name('Tốc độ Thời gian');

        const folderSea = gui.addFolder('Cài đặt Biển');
        folderSea.add(params, 'seaHeight', 0.1, 2.0).name('Độ cao Sóng').onChange(updateUniforms);
        folderSea.add(params, 'seaChoppy', 1.0, 8.0).name('Độ Gợn Sóng').onChange(updateUniforms);
        folderSea.add(params, 'seaSpeed', 0.1, 2.0).name('Tốc độ Sóng').onChange(updateUniforms);
        folderSea.add(params, 'seaFreq', 0.05, 0.5).name('Tần số Sóng').onChange(updateUniforms);

        gui.add(params, 'reset').name('Đặt lại mặc định');

        // 7. Event Listeners
        document.addEventListener('mousemove', function (e) {
            uniforms.iMouse.value.x = e.clientX;
            uniforms.iMouse.value.y = window.innerHeight - e.clientY;
        });
        document.addEventListener('mousedown', function (e) {
            uniforms.iMouse.value.z = 1.0;
            uniforms.iMouse.value.w = 1.0;
        });
        document.addEventListener('mouseup', function (e) {
            uniforms.iMouse.value.z = 0.0;
        });
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
        });

        // 8. Animation Loop
        const clock = new THREE.Clock();
        let accumulatedTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            accumulatedTime += delta * params.speed;
            uniforms.iTime.value = accumulatedTime;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>