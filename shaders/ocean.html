<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Procedural Ocean Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
</head>
<body>
<div id="container"></div>

<script>
    const container = document.getElementById('container');

    // 1. Cấu hình tham số GUI
    const params = {
        speed: 1.0,
        colorR: 0.0,
        colorG: 0.33,
        colorB: 0.67,
        specular: 0.13,
        reset: function() {
            this.speed = 1.0;
            this.colorR = 0.0;
            this.colorG = 0.33;
            this.colorB = 0.67;
            this.specular = 0.13;
            updateUniforms();
        }
    };

    // 2. Setup Three.js
    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    // 3. Uniforms
    const uniforms = {
        iTime: { value: 0 },
        iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },
        iMouse: { value: new THREE.Vector4() },
        uColorParams: { value: new THREE.Vector3(params.colorR, params.colorG, params.colorB) },
        uSpecular: { value: params.specular }
    };

    // 4. Shader Code (FIXED)
    const fragmentShader = `
        uniform float iTime;
        uniform vec3 iResolution;
        uniform vec4 iMouse;
        uniform vec3 uColorParams;
        uniform float uSpecular;

        // --- Constants ---
        #define AA 1.0
        #define STEPS 80.0
        #define MDIST 35.0
        #define pi 3.1415926535
        #define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))
        #define sat(a) clamp(a,0.0,1.0)

        #define ITERS_TRACE 9
        #define ITERS_NORM 20
        #define HOR_SCALE 1.1
        #define OCC_SPEED 1.4
        #define DX_DET 0.65
        #define FREQ 0.6
        #define HEIGHT_DIV 2.5
        #define WEIGHT_SCL 0.8
        #define FREQ_SCL 1.2
        #define TIME_SCL 1.095
        #define WAV_ROT 1.21
        #define DRAG 0.9
        #define SCRL_SPEED 1.5
        vec2 scrollDir = vec2(1,1);

        // --- Wave Functions ---
        vec2 wavedx(vec2 wavPos, int iters, float t){
            vec2 dx = vec2(0);
            vec2 wavDir = vec2(1,0);
            float wavWeight = 1.0; 
            wavPos+= t*SCRL_SPEED*scrollDir;
            wavPos*= HOR_SCALE;
            float wavFreq = FREQ;
            float wavTime = OCC_SPEED*t;
            for(int i=0;i<iters;i++){
                wavDir*=rot(WAV_ROT);
                float x = dot(wavDir,wavPos)*wavFreq+wavTime; 
                float result = exp(sin(x)-1.)*cos(x);
                result*=wavWeight;
                dx+= result*wavDir/pow(wavWeight,DX_DET); 
                wavFreq*= FREQ_SCL; 
                wavTime*= TIME_SCL;
                wavPos-= wavDir*result*DRAG; 
                wavWeight*= WEIGHT_SCL;
            }
            float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; 
            return dx/pow(wavSum,1.-DX_DET);
        }

        float wave(vec2 wavPos, int iters, float t){
            float wav = 0.0;
            vec2 wavDir = vec2(1,0);
            float wavWeight = 1.0;
            wavPos+= t*SCRL_SPEED*scrollDir;
            wavPos*= HOR_SCALE; 
            float wavFreq = FREQ;
            float wavTime = OCC_SPEED*t;
            for(int i=0;i<iters;i++){
                wavDir*=rot(WAV_ROT);
                float x = dot(wavDir,wavPos)*wavFreq+wavTime;
                float wave = exp(sin(x)-1.0)*wavWeight;
                wav+= wave;
                wavFreq*= FREQ_SCL;
                wavTime*= TIME_SCL;
                wavPos-= wavDir*wave*DRAG*cos(x);
                wavWeight*= WEIGHT_SCL;
            }
            float wavSum = -(pow(WEIGHT_SCL,float(iters))-1.)*HEIGHT_DIV; 
            return wav/wavSum;
        }

        vec3 norm(vec3 p){
            vec2 wav = -wavedx(p.xz, ITERS_NORM, iTime);
            return normalize(vec3(wav.x,1.0,wav.y));
        }

        float map(vec3 p){
            p.y-= wave(p.xz, ITERS_TRACE, iTime);
            return p.y;
        }

        // --- Color Functions ---
        vec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){
            return a+b*cos(2.0*pi*(c*t+d));
        }
        
        vec3 spc(float n,float bright){
            return pal(n, vec3(bright), vec3(0.5), vec3(1.0), uColorParams);
        }
        
        vec2 sunrot = vec2(-0.3,-0.25);

        vec3 sky(vec3 rd){
            float px = 1.5/min(iResolution.x,iResolution.y);
            vec3 rdo = rd;
            float rad = 0.075;
            vec3 col = vec3(0);

            rd.yz*=rot(sunrot.y);
            rd.xz*=rot(sunrot.x);
            float sFade = 2.5/min(iResolution.x,iResolution.y);
            float zFade = rd.z*0.5+0.5;
            
            vec3 sc = spc(uSpecular-0.1,0.6)*0.85;
            
            float a = length(rd.xy);
            vec3 sun=smoothstep(a-px-sFade,a+px+sFade,rad)*sc*zFade*2.;
            col+=sun;
            col+=rad/(rad+pow(a,1.7))*sc*zFade;
            col=col+mix(col,spc(uSpecular+0.1,0.8),sat(1.0-length(col)))*0.2;
            
            float e = 0.;
            vec3 p = rdo;
            p.xz*=0.4;
            p.x+=iTime*0.007;
            for(float s=200.;s>10.;s*=0.8){
                p.xz*=rot(s);
                p+=s;
                e+=abs(dot(sin(p*s+iTime*0.02)/s,vec3(1.65)));
            }
            e*=smoothstep(0.5,0.4,e-0.095);
            
            col += (e)*smoothstep(-0.02,0.3,rdo.y)*0.8*(1.0-sun*3.75)*mix(sc,vec3(1),0.4);
            return (col);
        }

        // --- Render Function ---
        void render( out vec4 fragColor, in vec2 fragCoord ){
            vec2 uv = (fragCoord-0.5*iResolution.xy)/min(iResolution.y,iResolution.x);
            vec3 col = vec3(0);
            vec3 ro = vec3(0,2.25,-3)*1.1;
            
            if(iMouse.z > 0.){
                ro.yz*=rot(2.0*min(iMouse.y/iResolution.y-0.5,0.15));
                ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));
            }
            vec3 lk = vec3(0,2,0);
            vec3 f = normalize(lk-ro);
            vec3 r = normalize(cross(vec3(0,1,0),f));
            vec3 rd = normalize(f*(0.9)+uv.x*r+uv.y*cross(f,r));

            float dO = 0.;
            bool hit = false;
            float d = 0.;
            vec3 p = ro;

            float tPln = -(ro.y-1.86)/rd.y;
            if(tPln>0. || iMouse.z>0.){
                if(iMouse.z <= 0.) dO+=tPln;
                for(float i = 0.; i<STEPS; i++){
                    p = ro+rd*dO;d = map(p);dO+=d;
                    if(abs(d)<0.005||i>STEPS-2.0){
                        hit = true; break;
                    }
                    if(dO>MDIST){ dO = MDIST; break; }
                }
            }
            vec3 skyrd = sky(rd);
            if(hit){
                vec3 n = norm(p);
                vec3 rfl = reflect(rd,n);
                rfl.y = abs(rfl.y);
                vec3 rf = refract(rd,n,1./1.33); 
                
                float fres = clamp((pow(1. - max(0.0, dot(-n, rd)), 5.0)),0.0,1.0);

                vec3 sunDir = vec3(0,0.15,1.0);
                sunDir.xz*=rot(-sunrot.x);
                col += sky(rfl)*fres*0.9;
                float subRefract =pow(max(0.0, dot(rf,sunDir)),35.0);
                
                col += pow(spc(uSpecular-0.1,0.5),vec3(2.2))*subRefract*2.5;
                vec3 rd2 = rd;
                rd2.xz*=rot(sunrot.x);
                vec3 waterCol = min(sat(spc(uSpecular-0.1,0.4))*0.05*pow(min(p.y+0.5,1.8),4.0)*length(skyrd)*(rd2.z*0.3+0.7),1.0);
                
                waterCol = sat(spc(uSpecular-0.1,0.4))*(0.4*pow(min(p.y*0.7+0.9,1.8),4.)*length(skyrd)*(rd2.z*0.15+0.85));
                col += waterCol*0.17;

                col = mix(col,skyrd,dO/MDIST);
            }
            else{
                col += skyrd;
            }
            col = sat(col);
            col = pow(col,vec3(0.87));
            col *=1.0-0.8*pow(length(uv*vec2(0.8,1.)),2.7);
            fragColor = vec4(col,1.0);
        }

        // --- Main Image (AA Logic) ---
        // ĐÂY LÀ HÀM BỊ THIẾU TRONG BẢN TRƯỚC
        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            float px = 1.0/AA;
            vec4 col = vec4(0);
            
            if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}
            
            // Nếu bật AA > 1.0 (nhưng hiện tại define AA 1.0 nên đoạn này không chạy)
            for(float i = 0.0; i < AA; i++){
                for(float j = 0.0; j < AA; j++){
                    vec4 col2;
                    vec2 coord = vec2(fragCoord.x+px*i, fragCoord.y+px*j);
                    render(col2, coord);
                    col.rgb+=col2.rgb;
                }
            }
            col/=AA*AA;
            fragColor = vec4(col);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    `;

    // 5. Mesh & Material
    const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        fragmentShader: fragmentShader,
        vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`
    });

    const plane = new THREE.PlaneGeometry(2, 2);
    const quad = new THREE.Mesh(plane, material);
    scene.add(quad);

    // 6. GUI Setup
    const gui = new lil.GUI({ title: 'Ocean Controls' });
    
    gui.add(params, 'speed', 0.0, 3.0).name('Tốc độ Sóng');
    
    const folderColor = gui.addFolder('Màu Sắc & Ánh Sáng');
    function updateUniforms() {
        uniforms.uColorParams.value.set(params.colorR, params.colorG, params.colorB);
        uniforms.uSpecular.value = params.specular;
    }

    folderColor.add(params, 'colorR', 0.0, 1.0).name('Pha Đỏ').onChange(updateUniforms);
    folderColor.add(params, 'colorG', 0.0, 1.0).name('Pha Xanh Lá').onChange(updateUniforms);
    folderColor.add(params, 'colorB', 0.0, 1.0).name('Pha Xanh Dương').onChange(updateUniforms);
    folderColor.add(params, 'specular', 0.0, 1.0).name('Độ Bóng').onChange(updateUniforms);
    gui.add(params, 'reset').name('Đặt lại mặc định');

    // 7. Event Listeners
    document.addEventListener('mousemove', function(e) {
        uniforms.iMouse.value.x = e.clientX;
        uniforms.iMouse.value.y = window.innerHeight - e.clientY;
    });
    document.addEventListener('mousedown', function(e) {
        uniforms.iMouse.value.z = 1.0; uniforms.iMouse.value.w = 1.0;
    });
    document.addEventListener('mouseup', function(e) {
        uniforms.iMouse.value.z = 0.0;
    });
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
    });

    // 8. Loop
    const clock = new THREE.Clock();
    let accumulatedTime = 0;

    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        accumulatedTime += delta * params.speed;
        uniforms.iTime.value = accumulatedTime;
        
        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>
