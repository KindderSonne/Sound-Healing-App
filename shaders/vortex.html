<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Vortex Shader - Standalone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>

    <script>
        const canvas = document.getElementById("glcanvas");
        const gl = canvas.getContext("webgl2");

        if (!gl) {
            alert("Trình duyệt của bạn không hỗ trợ WebGL 2.0");
        }

        // ==========================================
        // VERTEX SHADER (Đơn giản, vẽ 1 hình chữ nhật phủ kín màn hình)
        // ==========================================
        const vsSource = `#version 300 es
        in vec4 position;
        void main() {
            gl_Position = position;
        }`;

        // ==========================================
        // FRAGMENT SHADER (Code của Xor/Kishimisu)
        // ==========================================
        const fsSource = `#version 300 es
        precision highp float;
        
        uniform vec3 iResolution;
        uniform float iTime;
        out vec4 fragColor;

        // --- BẮT ĐẦU CODE USER ---
        
        // Fix: Đổi 'out' thành 'inout' vì code golf đọc giá trị O trước khi ghi
        #define R mat2(cos(vec4(0,11,33,0)

        void mainImage(inout vec4 O, vec2 F) {
            vec3    V             = iResolution, 
                      o           ;
            float       r         = iTime,
                          t       , 
                            e     , 
                              x   ;

            // Lưu ý: Biến 'e' không được khởi tạo (code golf trick).
            // WebGL thường mặc định là 0, nhưng nếu glitch xảy ra, hãy gán e=0.
            for (O *= e; e++ < 40.;
                
                o.y += t*t*.09,
                o.z = mod(o.z + r, .2) - .1,
                x = t*.06 - r*.2,
                
                o.x = fract(
                    o.xy *= R+round((atan(o.y, o.x) - x) / .314) * .314 + x))
                ).x - .8,
                
                t += x = length(o)*.5 - .014,
                
                O += (1. + cos(t*.5 + r + vec4(0,1,2,0))) 
                    * (.3 + sin(3.*t + r*5.)/4.)
                    / (8. + x*4e2)
            )
                o = t * normalize(vec3((F+F-V.xy)*R+r*.15)),V.y));
        }
        // --- KẾT THÚC CODE USER ---

        void main() {
            vec4 color = vec4(0.0);
            mainImage(color, gl_FragCoord.xy);
            fragColor = color;
        }
        `;

        // ==========================================
        // WEBGL BOILERPLATE SETUP
        // ==========================================

        // 1. Compile Shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Lỗi compile shader:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        // 2. Link Program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Lỗi link program:", gl.getProgramInfoLog(program));
        }

        // 3. Setup Geometry (Full screen triangle strip)
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // Vẽ 2 tam giác che kín màn hình (-1 đến 1)
        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, "position");
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // 4. Uniform Locations
        const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
        const iTimeLocation = gl.getUniformLocation(program, "iTime");

        // 5. Render Loop
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function render(time) {
            time *= 0.001; // Chuyển ms sang giây

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            // Cập nhật Uniforms
            gl.uniform3f(iResolutionLocation, canvas.width, canvas.height, 1.0);
            gl.uniform1f(iTimeLocation, time);

            // Vẽ
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>

</html>