<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Raymarching Octahedron - WebGL</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="container"></div>

    <script>
        const container = document.getElementById('container');

        // 1. Khởi tạo Three.js cơ bản
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 2. Định nghĩa các biến Uniforms (Dữ liệu truyền từ JS vào Shader)
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },
            iMouse: { value: new THREE.Vector4(0, 0, -1, -1) } // x, y, click_status, click_start
        };

        // 3. Nội dung Shader (GLSL)
        // Đây là phần code bạn cung cấp, được bọc trong fragmentShader
        const fragmentShader = `
        precision highp float;

        uniform vec3 iResolution;
        uniform float iTime;
        uniform vec4 iMouse;

        // --- BẮT ĐẦU CODE SHADERTOY ---

        // 2D rotation function
        mat2 rot2D(float a) {
            return mat2(cos(a), -sin(a), sin(a), cos(a));
        }

        // Custom gradient - https://iquilezles.org/articles/palettes/
        vec3 palette(float t) {
            return .5+.5*cos(6.28318*(t+vec3(.3,.416,.557)));
        }

        // Octahedron SDF - https://iquilezles.org/articles/distfunctions/
        float sdOctahedron(vec3 p, float s) {
            p = abs(p);
            return (p.x+p.y+p.z-s)*0.57735027;
        }

        // Scene distance
        float map(vec3 p) {
            p.z += iTime * .4; // Forward movement
            
            // Space repetition
            p.xy = fract(p.xy) - .5;     // spacing: 1
            p.z =  mod(p.z, .25) - .125; // spacing: .25
            
            return sdOctahedron(p, .15); // Octahedron
        }

        // Hàm mainImage gốc của Shadertoy
        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
            vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;
            vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;
            
            // Default circular motion if mouse not clicked
            if (iMouse.z <= 0.) m = vec2(cos(iTime*.2), sin(iTime*.2));

            // Initialization
            vec3 ro = vec3(0, 0, -3);          // ray origin
            vec3 rd = normalize(vec3(uv, 1)); // ray direction
            vec3 col = vec3(0);               // final pixel color

            float t = 0.; // total distance travelled

            int i; // Raymarching
            for (i = 0; i < 80; i++) {
                vec3 p = ro + rd * t; // position along the ray
                
                p.xy *= rot2D(t*.15 * m.x);     // rotate ray around z-axis

                p.y += sin(t*(m.y+1.)*.5)*.35;  // wiggle ray

                float d = map(p);     // current distance to the scene

                t += d;               // "march" the ray

                if (d < .001 || t > 100.) break; // early stop
            }

            // Coloring
            col = palette(t*.04 + float(i)*.005);

            fragColor = vec4(col, 1);
        }
        // --- KẾT THÚC CODE SHADERTOY ---

        // Hàm main chuẩn của WebGL gọi hàm của Shadertoy
        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    `;

        // 4. Tạo Material và Mesh
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            fragmentShader: fragmentShader,
            vertexShader: `
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        `
        });

        const plane = new THREE.PlaneGeometry(2, 2);
        const quad = new THREE.Mesh(plane, material);
        scene.add(quad);

        // 5. Xử lý sự kiện (Mouse & Resize)

        // Cập nhật kích thước màn hình
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
        });

        // Xử lý chuột
        document.addEventListener('mousemove', (e) => {
            uniforms.iMouse.value.x = e.clientX;
            uniforms.iMouse.value.y = window.innerHeight - e.clientY; // Đảo ngược trục Y cho giống Shadertoy
        });

        document.addEventListener('mousedown', (e) => {
            uniforms.iMouse.value.z = 1; // Đánh dấu đang click
            uniforms.iMouse.value.w = 1;
        });

        document.addEventListener('mouseup', (e) => {
            uniforms.iMouse.value.z = -1; // Đánh dấu thả chuột
        });

        // 6. Vòng lặp Render
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            // Cập nhật thời gian
            uniforms.iTime.value = clock.getElapsedTime();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>