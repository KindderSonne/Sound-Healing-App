<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Chrome Dreams - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="container"></div>

    <script>
        const container = document.getElementById('container');

        // 1. Setup Three.js
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 2. Uniforms
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) }
        };

        // 3. Shader Code (Chuẩn hóa từ bản gốc của kishimisu/Xor)
        const fragmentShader = `
        precision highp float;
        
        uniform vec3 iResolution;
        uniform float iTime;

        // Hàm tạo ma trận xoay 2D
        mat2 rot(float a) {
            float c = cos(a), s = sin(a);
            return mat2(c, -s, s, c);
        }

        // Hàm trộn (mix) tùy chỉnh từ shader gốc
        float a_mix(float a, float b, float f, float o, float e) {
            return mix(a, b, sin(o + e * f) * 0.5 + 0.5);
        }

        void mainImage(out vec4 O, vec2 F) {
            float c = 0.0;
            float o = 0.0;
            float d = 3.0;
            float e = iTime * 0.4;
            
            vec2 r = iResolution.xy;
            
            // Vòng lặp Raymarching
            for (int i = 0; i < 200; i++) {
                if (d <= 0.001) break; // Dừng nếu chạm vật thể

                // Khởi tạo tia
                vec3 p = abs(0.7 * c * normalize(vec3((F + F - r) / r.y, 1.0)));
                
                // Biến đổi không gian (Space Folding & Rotation)
                p.xy *= rot(e);
                p.zy += e + c * 0.2;
                p = fract(p) - 0.5; // Lặp lại không gian (Space repetition)
                
                p.xy *= rot(c);
                p.xz *= rot(e);
                
                // SDF (Signed Distance Function) cho hình khối
                // a(0.,.2,1.,) trong code gốc tương đương với a_mix(0.0, 0.2, 1.0, 0.0, e)
                p.y = max(abs(p.y) - a_mix(0.0, 0.2, 1.0, 0.0, e), 0.0);
                
                // Tính khoảng cách
                float sphereDist = length(vec2(length(p.xy) - 0.2, p.z));
                float noise = a_mix(0.04, 0.1, 0.5, 4.0, e);
                
                d = (sphereDist - noise - c * 0.01) * 0.5;
                
                c += d;
                o += 1.0;
            }
            
            // Tính màu sắc (Coloring) dựa trên khoảng cách tích lũy 'c'
            vec3 colorBase = cos(c * 6.0 + 0.8 * vec3(0.0, 1.0 + c * 0.04, 2.0)) + 0.2;
            vec3 glow = 1.2 * colorBase / exp(c * 0.14);
            
            O = vec4(glow, 1.0);
        }

        void main() {
            mainImage(gl_FragColor, gl_FragCoord.xy);
        }
    `;

        // 4. Create Material & Mesh
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            fragmentShader: fragmentShader,
            vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`
        });

        const plane = new THREE.PlaneGeometry(2, 2);
        const quad = new THREE.Mesh(plane, material);
        scene.add(quad);

        // 5. Resize Event
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
        });

        // 6. Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            uniforms.iTime.value = clock.getElapsedTime();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>